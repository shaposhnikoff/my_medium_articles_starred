Unknown markup type 10 { type: [33m10[39m, start: [33m44[39m, end: [33m55[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m119[39m, end: [33m130[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m152[39m, end: [33m159[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m234[39m, end: [33m241[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m15[39m, end: [33m22[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m292[39m, end: [33m301[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m344[39m, end: [33m352[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m357[39m, end: [33m369[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m39[39m, end: [33m46[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m111[39m, end: [33m118[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m298[39m, end: [33m305[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m314[39m, end: [33m322[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m364[39m, end: [33m376[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m10[39m, end: [33m17[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m273[39m, end: [33m281[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m40[39m, end: [33m53[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m45[39m, end: [33m58[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m199[39m, end: [33m212[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m33[39m, end: [33m52[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m225[39m, end: [33m236[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m277[39m, end: [33m288[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m140[39m, end: [33m142[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m204[39m, end: [33m218[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m231[39m, end: [33m235[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m252[39m, end: [33m254[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m311[39m, end: [33m315[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m374[39m, end: [33m378[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m24[39m, end: [33m29[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m34[39m, end: [33m42[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m123[39m, end: [33m124[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m146[39m, end: [33m159[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m168[39m, end: [33m172[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m205[39m, end: [33m218[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m44[39m, end: [33m48[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m170[39m, end: [33m178[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m183[39m, end: [33m191[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m195[39m, end: [33m196[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m90[39m, end: [33m123[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m197[39m, end: [33m230[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m128[39m, end: [33m132[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m19[39m, end: [33m20[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m25[39m, end: [33m27[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m62[39m, end: [33m82[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m91[39m, end: [33m102[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m156[39m, end: [33m158[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m181[39m, end: [33m182[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m321[39m, end: [33m331[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m344[39m, end: [33m354[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m358[39m, end: [33m379[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m486[39m, end: [33m496[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m108[39m, end: [33m119[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m241[39m, end: [33m253[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m47[39m, end: [33m49[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m53[39m, end: [33m64[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m70[39m, end: [33m71[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m112[39m, end: [33m133[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m137[39m, end: [33m138[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m243[39m, end: [33m254[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m183[39m, end: [33m184[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m445[39m, end: [33m456[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m478[39m, end: [33m491[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m509[39m, end: [33m510[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m549[39m, end: [33m550[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m51[39m, end: [33m93[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m127[39m, end: [33m128[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m248[39m, end: [33m259[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m67[39m, end: [33m69[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m94[39m, end: [33m96[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m28[39m, end: [33m39[39m }

# Securing k8s application using ingress rule/nginx ingress controller

Photo by Scott Webb on Unsplash

In this blog post we are going to look into how we can secure a Kubernetes application at the ingress level. I am saying ingress level because there are other ways to secure your application which we can talk in other blog post maybe.

But before diving into that let‚Äôs take a step back and look into how we actually expose our Kubernetes application to the outer world.

I have discussed this briefly in one of my other blog post as well.
[**Hello World!!! of Kubernetes [Part 1]**
*So, I started working with containers and Kubernetes some months back, was an absolute beginner to the field before‚Ä¶*medium.com](https://medium.com/faun/hello-world-of-kubernetes-part-1-d1153fc2fc37)

![](https://cdn-images-1.medium.com/max/2000/1*_ghJ2Eq-Fl46aQT2EcxTow.png)

As you can see in the diagram to expose the Deployment (application), which eventually is managing a set of pods using ReplicaSets, ideally we create a Service and then that service will be exposed to the outer world using Kubernetes Ingress resources.

While creating Service you can argue that which kind (type) of service you should go with, we will not discuss that in detail in this post but in very simple words if the the service that exposes your application is being accessed by other application in the same cluster, you should go with ClusterIP type of service or you can look up to the NodePort and LoadBalancer types.

## Kubernetes Ingress resource

I have already talked about Kubernetes Ingress resource in my previously mentioned post but to summarise that, Ingress is like any other Kubernetes resource that is used to expose your application to outside world. There are other ways to expose your application to the outside world like creating Service of type NodePort or if you are on a cloud provider, using LoadBalancer.

But using Ingress to expose your application to outside words has several benefits over the other option of creating service. For example in Service you can not have resource path or host based routing.

To get the Ingress resource working we also need an ingress controller, otherwise the Ingress resource that you create will silently fail and have no effect. Deploying the ingress controller totally depends on how you have setup your Kubernetes cluster, since I am running minikube cluster, I will be using nginx ingress controller and I can enable that just by running command

    minikube addons enable ingress

You can follow [this link](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/) to get to know about the options that we have for ingress controllers.

What we are going to do now is run an Elasticsearch in out Kubernetes cluster, access it without security and then secure it using basic authentication. This blog post is highly inspired by the post that is there in nginx‚Äô [examples](https://kubernetes.github.io/ingress-nginx/examples/auth/basic/) page.

Run an Elasticsearch instance using below command

    # we are going to use imperative ways of creating some of the 
    # resources, these resource can very well be created using manifests
    # as well.

    # this is not how you are going to run Elasticsearch on production 
    # envs, but we are not focusing on that as of now.

    kubectl run elasticsearch --image elastic/elasticsearch:6.6.2

this command creates a deployment named elasticsearch in our cluster that eventually runs an Elasticsearch instance. To access the this cluster from outside as shown in the previous diagram we will have to create a service and then an ingress.

Create the service to expose the deployment (elasticsearch) that we have created earlier

    ~ kubectl get deployments.apps 
    NAME            READY   UP-TO-DATE   AVAILABLE   AGE
    elasticsearch   1/1     1            1           44m

    ~ kubectl get service
    NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
    kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   4d9h

    ~ kubectl expose deployment elasticsearch --type ClusterIP --port 9200
    service/elasticsearch exposed

    ~ kubectl get service
    NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
    elasticsearch   ClusterIP   10.104.116.45   <none>        9200/TCP   11m
    kubernetes      ClusterIP   10.96.0.1       <none>        443/TCP    4d9h

As you can see we have created the deployment that runs Elasticsearch instance and a Service to expose that deployment, now lets go ahead and try to create the ingress that will expose this Service (elasticsearch), that we have created, to the outside world.

    apiVersion: networking.k8s.io/v1beta1
    kind: Ingress
    metadata:
      # name of this ingress rule
      name: es-ingress
    spec:
      rules:
      # specify the protocal, this rule should be applied for
      - http:
          paths:
          # specify the resource path to which this rule should be applied
          - path: /
            # specify the service, the request should be forwarded to 
            backend: 
              serviceName: elasticsearch
              servicePort: 9200

Create the ingress by saving the above manifest to a file let‚Äôs say ingress.yaml and then running

    kubectl create -f ingress.yaml

Once we have created the running kubectl get ingress command should return below

    ~ kubectl get ingresses.
    NAME         HOSTS   ADDRESS   PORTS   AGE
    es-ingress   *                 80      7s

Now, if you go back to the diagram that I showed earlier, we have created all the components that are required to access our application from outside. Now lets just go ahead and try to access our application by accessing the minikube ip, you can get the that using the command minikube ip.

![accessing ES instance using minikube ip](https://cdn-images-1.medium.com/max/2000/1*NiH1wE8JB-B1LMQIbxYGnw.png)*accessing ES instance using minikube ip*

And you can see that we are successfully able to access the Elasticsearch instance.

Now there is an important thing to understand here, and that is the URI that we are using to access that Elasticsearch instance.

![ingress port](https://cdn-images-1.medium.com/max/2000/1*5E4PZwzlK7_kAAvAR32weg.png)*ingress port*

If you just get the details of the ingress that we have just created, you will easily get to know that the ingress is listening on the port 80 and that‚Äôs why we are not providing any port while accessing Elasticsearch here because HTTP default port is 80 . Now we know that Elasticsearch ideally serves on port 9200, that simply means traffic is somehow being redirected on 9200 of the pod that has been created.

To understand that lets describe the ingress resource

![we can easily see that this ingress will redirect all the traffic to the service elasticsearch on port 9200](https://cdn-images-1.medium.com/max/2000/1*xqjmrlwxgECKd0HXB_LsfA.png)*we can easily see that this ingress will redirect all the traffic to the service elasticsearch on port 9200*

here you can see, under Rules and Backends, that the ingress will redirect all the traffic that comes at the resource path / to the service names elasticsearch on port 9200 and we know that, that service (elasticsearch) is going to redirect the traffic to correct port of the pod because we got that service by exposing the deployment.

Now that we have the our application accessible from outside of cluster, lets try to secure it.

## Securing the application

Securing the Elasticsearch application that we just deployed has three main and simple parts.

### Create credentials file

To create a credentials file that will store your username and password run below command

    user@anakata ~ htpasswd -c auth <username>
    New password: 
    Re-type new password: 
    Adding password for user <username>

After this command you will have file named auth in you current directory. The credentials that you entered here will be used to login to your application when asked for username and password.

### Create the secret resource using credentials file

Now we will have to create secret that will be referred in our ingress resource to secure our application. use below command to create the secret

    # kubectl create secret generic <secret-name> --from-file <file-name>
    kubectl create secret generic basic-auth --from-file auth 
    secret/basic-auth created

To get to know more about secrets you can refer to below blog post
[**Hello World!!! of Kubernetes [Part 3]**
*In the last blog post of this series we discussed about how to use several kubernetes resources to get multiple tiers‚Ä¶*medium.com](https://medium.com/faun/hello-world-of-kubernetes-part-3-5076682add36)

Once we have the secret created lets go ahead and change the ingress resource in such a way that it will now ask for username and password if someone tries to access the ingress at resource path / .

### Change ingress rule to secure the service using the secret

Change the ingress manifest that we had earlier to the manifest below, we are just introducing the [annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/) to the Ingress resource.

    apiVersion: networking.k8s.io/v1beta1
    kind: Ingress
    metadata:
      # name of this ingress rule
      name: es-ingress
      annotations:
        # type of authentiation 
        nginx.ingress.kubernetes.io/auth-type: basic
        # secret reference that contins the credential detals
        nginx.ingress.kubernetes.io/auth-secret: basic-auth
    spec:
      rules:
      # specify the protocal, this rule should be applied for
      - http:
          paths:
          # specify the resource path to which this rule should be applied
          - path: /
            # specify the service, the request should be forwarded to 
            backend: 
              serviceName: elasticsearch
              servicePort: 9200

save this manifest with whatever name you like (es-ingress.yaml) and then create it using kubectl create -f es-ingress.yaml command. Please make sure to delete the previously created ingress using kubectl delete ingress es-ingress.

Once you have created the new ingress, lets try to access the same URL, and see what happens

![secured ES instance](https://cdn-images-1.medium.com/max/2000/1*pQNuasJq44lmun4k5EQ4Hg.png)*secured ES instance*

and here we go, we are asked for the username and password and if we provide the same username and password that we created the auth file with, we will successfully be able to access the Elasticsearch application.

Now that we have secured our application successfully, we should take a deeper look into the ingress yaml file that we had to create the ingress resource.

![](https://cdn-images-1.medium.com/max/2000/1*JLaCzzCgUYnhS1aucBkUkw.png)

In the line number 8 and 10 we are telling ingress to use the basic authentication and the secret name respectively. The line I would like to talk about is 17, the value of path is / and that simply means that this authentication will be applied to all other sub resource, for example if you are running another service (serviceone) and access serviceone by minikubeip/serviceone , you will be asked for the credentials which is not the requirement. Because you dont want that service (serviceone) to be secured through basic authentication.

![accessing serviceone also asks for credentials which is not expected](https://cdn-images-1.medium.com/max/2000/1*ft817HdUtu8KxPRPfWOFrA.png)*accessing serviceone also asks for credentials which is not expected*

To resolve that what we can do is configure Elasticsearch to be accessed on another resource path let‚Äôs say /secured-es, and then we will configure ingress in such a way that it will only secure the requests that are coming at resource path /secured-es.

To do that just change the path in line number 17 to /secured-es from / and then try to access the the endpoint minikubeip/secured-es

You will still get the prompt for username and password, please enter the password and

![](https://cdn-images-1.medium.com/max/2000/1*LcN-Pdy62uV-KvL2XhZE5A.png)

whoa, it seems things are breaking now. It seems that we are able to talk to the Elasticsearch cluster but we are not querying the root (/) resource path which is what we are supposed to do. It seems that now we are querying the resource path /secured-es in Elasticsearch instance and it returns this error.
> The reason is by default the requests will be forwarded to same resource path that is mentioned in your ingress file, but what if your application is listening at root resource path (/)or somewhere else. If we have mentioned a resource path in the ingress where our application is not listening we will have to rewrite the target to the resource path where our application is listening. For example in ingress manifest we are providing the path /secured-es but our application (Elasticsearch) is listening at / so will have to rewrite the target to /.

We can easily do that by adding another annotation nginx.ingress.kubernetes.io/rewrite-target with the value of resource path (/) where your application is listening, in the ingress manifest and this will enable us to only secure the resource path /secured-es where our Elasticsearch application is deployed and other resource paths will be accessible without any issues.

The final ingress resource would be, as you see we have added line 11 to rewrite the target to /

![[https://gist.github.com/viveksinghggits/ef6a2abd2002b863400b2f7d7fae7c93](https://gist.github.com/viveksinghggits/ef6a2abd2002b863400b2f7d7fae7c93)](https://cdn-images-1.medium.com/max/2000/1*NTl4L0q6bw-8wgbNDm0t4g.png)*[https://gist.github.com/viveksinghggits/ef6a2abd2002b863400b2f7d7fae7c93](https://gist.github.com/viveksinghggits/ef6a2abd2002b863400b2f7d7fae7c93)*

Now accessing resource path /secured-es will ask for username and password

![](https://cdn-images-1.medium.com/max/2000/1*6MmJ0A_vAhqqzH38xq_Qow.png)

But other endpoints will not be secured, as required

![we are getting 404 here because we dont have any application for resource path /serviceone](https://cdn-images-1.medium.com/max/2000/1*HDwN7Hl4u0zVcPWu6nIOHw.png)*we are getting 404 here because we dont have any application for resource path /serviceone*

The things that we discussed at the very last can be a but confusing please let me know your questions either here or ping me on [twitter](https://twitter.com/viveksinghggits), I would be more than happy to help.

![](https://cdn-images-1.medium.com/max/2000/0*q8snkG3cBIz21Dkw)

**Follow us on [Twitter](https://twitter.com/joinfaun) **üê¶** and [Facebook](https://www.facebook.com/faun.dev/) **üë•** and join our [Facebook Group](https://www.facebook.com/groups/364904580892967/)**üí¨**.**

**To join our community Slack **üó£Ô∏è **and read our weekly Faun topics **üóûÔ∏è,**click here‚¨á**

![](https://cdn-images-1.medium.com/max/2000/0*9oUI61xFXneOLtU0)

![](https://cdn-images-1.medium.com/max/3200/0*Tptt7fOzRsGnI1YN)

## If this post was helpful, please click the clap üëè button below a few times to show your support for the author! ‚¨á
